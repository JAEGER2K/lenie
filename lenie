#!/usr/bin/luajit
-- TODO Investigate how code hygene can be improved via Lua-environments


--{{{ UTIL FUNCTIONS
function file_exists(fname)
	local fd = io.open(fname, 'r')
	if io.type(fd) ~= nil then
		fd:close()
		return true
	else
		return false
	end
end

function installed(pname)
	local path = "/usr/bin/" .. pname
	return file_exists(path)
end

-- Get sha1 of most recent commit from the blogs git repository
function get_revision()
	local fd = io.popen("git log -1 | grep commit | awk '{ print $2 }'")
	local rev = fd:read("*a")
	fd:close()
	return rev
end

-- In the src directory there is a file "rev" that stores the sha1 of the commit associated with
-- the current state of the blog. Note that this is not necessarily the commit that is checked
-- out in the src directory; it refers to the generated HTML files and indicates whether the
-- blog - as seen by the web server - is out of sync with the blogs repository.
-- This function does the comparison and returns true if the blog is in sync with the repo.
function up_to_date(srcdir)
	local fd = io.open(srcdir.."/rev", 'r')
	if fd then
		local checked_out = fd:read("*l")
		fd:close()
		if get_revision() == checked_out then return true end
	end
	return false
end

-- Set up and configure the bare repository to automatically create static HTML files for the
-- web server upon receiving blog pusts via git push
function prepare()
	-- Make sure all programs required to run this script are installed
	local req_progs = {"markdown", "git", "grep", "awk"}
	for ix,prog in ipairs(req_progs) do
		if not installed(prog) then
			print("ERROR: The program "..prog.." is required but can't be found")
			os.exit()
		end
	end

	-- Read runtime config or, if it does not exist, create a template rc.lua
	--[=[ TODO This should be done in the init routine, if at all
	local fname = PWD.."/rc.lua"
	if not file_exists(fname) then
		local rc = [[
		color = "#fff"
		background = "#000"
		]]
		local fd = io.open(PWD.."/rc.lua", 'w')
		if fd then
			fd:write(rc)
			fd:close()
		end
	end
	dofile(fname)
	]=]

	--[[ If no style.css exists, create a template
	-- TODO re-evaluate
	local fname = PWD.."/style.css"
	if not file_exists(fname) then
		local fd = io.open(fname, 'w')
		local css = "body{color: #fff; background: #000; padding: 50px 20% 50px 20%}"
		fd:write(css)
		fd:close()
	end
	]]
end
--}}}


--{{{ PATH 1: GENERATING STATIC HTML
-- Create table with files that need to be generated, sorted by date of modification
function gather_mdfiles(src)
	local mdfiles = {}
	for fname in io.popen('ls -t "' .. src .. '"'):lines() do
		local mdfile = fname:match('^.+%.md$')
		if mdfile then
			mdfiles[#mdfiles+1] = mdfile
		end
	end
	return mdfiles
end

-- Read the runtime config and return a table with the configuration state. If there is no rc
-- file, create one with default values and return these.
function read_rc(src)
	-- TODO Compiling the rc file should be done in a sandboxed environment in order to keep the global environment clean
end

function gen_html(src, mdfiles)
	-- Create HTML header and footer
	local html_head = [[
	<html>
	<link href="style.css" rel="stylesheet">
	<body>
	]]
	local html_foot = [[
	</body>
	</html>
	]]

	-- Convert markdown files to HTML and store each one as string in an array "posts"
	local posts = {}
	for ix,fname in ipairs(mdfiles) do
		-- TODO Extract info about file creation- and modification-date from git index
		local fd = io.popen("markdown --html4tags " .. src .. "/" .. fname)
		posts[ix] = fd:read('*a')
		fd:close()
	end

	-- concatenate HTML header, parsed markdown-body and HTML footer
	local separator = "\n<br /><hr><br />\n"
	local html_body = table.concat(posts, separator)
	return html_head .. html_body .. html_foot
end

function gen_css(src, rc)
	-- TODO Test if that is even necessary, possibly before entering this function
end

-- Read all files in the specified source directory "src" and generate HTML code to be stored in
-- destination directory "dst"
function generate(src, dst)
	if up_to_date(src) then return "Blog already up to date" end

	local mdfiles = gather_mdfiles(src)

	local index_html = gen_html(src, mdfiles)

	-- Write HTML file
	do
		local fd = io.open(dst .. "/index.html", 'w')
		fd:write(index_html)
		fd:close()
	end

	-- Update rev file to most recent commit hash
	do
		local fd = io.open(src.."/rev", 'w+')
		fd:write( get_revision() )
		fd:close()
	end

	return "Blog updated!"
end
--}}}


--{{{ PATH 2: INITIAL SETUP
-- Initialize the git repository for the server and configure it.
function init( repo_path, www_path )
	-- TODO create directory repo_path, repo_path/src
	-- TODO create bare repository in repo_path/git
	-- TODO add post-receive hook
	local hints = {
		[[Don't forget to add the SSH keys of everyone who should be able to push to this blog
		to '$HOME/.ssh/authorized_keys'. See man ssh for details.]],
		[[Make sure the permissions of the directory where the HTML pages should be written are
		set properly. The user calling "lenie generate" must have permission to write there and
		the webserver must have permission to read the files there.]],
	}
	print("Setup completed. The blog repository has been created at " .. repo_path ..
	" and has been configured to save all generated HTML files to " .. www_path)
	for ix,str in ipairs( hints ) do
		print("Hint " .. ix .. ": " .. str)
	end
end
--}}}


--{{{ MAIN
function print_usage()
	local usage = {
		[[lenie init <path of repo> <path to www dir observed by webserver>]],
		[[lenie generate <path to src dir> <path to dest dir>]],
	}
	for ix,str in ipairs(usage) do
		print("usage ["..ix.."]: " .. str)
	end
end

-- Parse input arguments
if arg[1] == "generate" or arg[1] == "gen" then
	local srcdir, dstdir = arg[2], arg[3]
	if srcdir == nil or dstdir == nil then
		print("ERROR: Arguments missing.")
		print_usage()
		os.exit()
	end
	prepare()
	local result = generate(srcdir, dstdir)
	print( result )
elseif arg[1] == "initialize" or arg[1] == "init" then
	local repo_path, www_path = arg[2], arg[3]
	if not repo_path or not www_path then
		print("ERROR: Arguments missing.")
		print_usage()
		os.exit()
	end
	print("Sorry, this feature has not yet been fully implemented")
else
	print_usage()
	os.exit()
end
--}}}
